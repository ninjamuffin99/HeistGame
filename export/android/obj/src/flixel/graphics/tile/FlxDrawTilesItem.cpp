// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxDrawBaseItem
#include <flixel/graphics/tile/FlxDrawBaseItem.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxDrawItemType
#include <flixel/graphics/tile/FlxDrawItemType.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxDrawTilesItem
#include <flixel/graphics/tile/FlxDrawTilesItem.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_DisplayObject
#include <openfl/_legacy/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_DisplayObjectContainer
#include <openfl/_legacy/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_Graphics
#include <openfl/_legacy/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_InteractiveObject
#include <openfl/_legacy/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_Sprite
#include <openfl/_legacy/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_Tilesheet
#include <openfl/_legacy/display/Tilesheet.h>
#endif
#ifndef INCLUDED_openfl__legacy_events_EventDispatcher
#include <openfl/_legacy/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl__legacy_events_IEventDispatcher
#include <openfl/_legacy/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_ColorTransform
#include <openfl/_legacy/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Matrix
#include <openfl/_legacy/geom/Matrix.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_94b10b66a3cf0a9a_13_new,"flixel.graphics.tile.FlxDrawTilesItem","new",0x1450ef83,"flixel.graphics.tile.FlxDrawTilesItem.new","flixel/graphics/tile/FlxDrawTilesItem.hx",13,0xdffe6dcc)
HX_LOCAL_STACK_FRAME(_hx_pos_94b10b66a3cf0a9a_27_reset,"flixel.graphics.tile.FlxDrawTilesItem","reset",0xcba5b7b2,"flixel.graphics.tile.FlxDrawTilesItem.reset","flixel/graphics/tile/FlxDrawTilesItem.hx",27,0xdffe6dcc)
HX_LOCAL_STACK_FRAME(_hx_pos_94b10b66a3cf0a9a_34_dispose,"flixel.graphics.tile.FlxDrawTilesItem","dispose",0xa4cb6d42,"flixel.graphics.tile.FlxDrawTilesItem.dispose","flixel/graphics/tile/FlxDrawTilesItem.hx",34,0xdffe6dcc)
HX_LOCAL_STACK_FRAME(_hx_pos_94b10b66a3cf0a9a_41_addQuad,"flixel.graphics.tile.FlxDrawTilesItem","addQuad",0x70c6682b,"flixel.graphics.tile.FlxDrawTilesItem.addQuad","flixel/graphics/tile/FlxDrawTilesItem.hx",41,0xdffe6dcc)
HX_LOCAL_STACK_FRAME(_hx_pos_94b10b66a3cf0a9a_79_setNext,"flixel.graphics.tile.FlxDrawTilesItem","setNext",0xf805b258,"flixel.graphics.tile.FlxDrawTilesItem.setNext","flixel/graphics/tile/FlxDrawTilesItem.hx",79,0xdffe6dcc)
HX_LOCAL_STACK_FRAME(_hx_pos_94b10b66a3cf0a9a_83_render,"flixel.graphics.tile.FlxDrawTilesItem","render",0x620c2413,"flixel.graphics.tile.FlxDrawTilesItem.render","flixel/graphics/tile/FlxDrawTilesItem.hx",83,0xdffe6dcc)
HX_LOCAL_STACK_FRAME(_hx_pos_94b10b66a3cf0a9a_110_get_numTiles,"flixel.graphics.tile.FlxDrawTilesItem","get_numTiles",0xd57429e5,"flixel.graphics.tile.FlxDrawTilesItem.get_numTiles","flixel/graphics/tile/FlxDrawTilesItem.hx",110,0xdffe6dcc)
HX_LOCAL_STACK_FRAME(_hx_pos_94b10b66a3cf0a9a_124_get_numVertices,"flixel.graphics.tile.FlxDrawTilesItem","get_numVertices",0x8b0e8f99,"flixel.graphics.tile.FlxDrawTilesItem.get_numVertices","flixel/graphics/tile/FlxDrawTilesItem.hx",124,0xdffe6dcc)
HX_LOCAL_STACK_FRAME(_hx_pos_94b10b66a3cf0a9a_129_get_numTriangles,"flixel.graphics.tile.FlxDrawTilesItem","get_numTriangles",0x37fe0d0b,"flixel.graphics.tile.FlxDrawTilesItem.get_numTriangles","flixel/graphics/tile/FlxDrawTilesItem.hx",129,0xdffe6dcc)
namespace flixel{
namespace graphics{
namespace tile{

void FlxDrawTilesItem_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_94b10b66a3cf0a9a_13_new)
HXLINE(  16)		this->position = (int)0;
HXLINE(  15)		this->drawData = ::Array_obj< Float >::__new(0);
HXLINE(  22)		super::__construct();
HXLINE(  23)		this->type = ::flixel::graphics::tile::FlxDrawItemType_obj::TILES_dyn();
            	}

Dynamic FlxDrawTilesItem_obj::__CreateEmpty() { return new FlxDrawTilesItem_obj; }

void *FlxDrawTilesItem_obj::_hx_vtable = 0;

Dynamic FlxDrawTilesItem_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxDrawTilesItem_obj > _hx_result = new FlxDrawTilesItem_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FlxDrawTilesItem_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x18d0451d) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x18d0451d;
	} else {
		return inClassId==(int)0x2b5673bf;
	}
}

void FlxDrawTilesItem_obj::reset(){
            	HX_STACKFRAME(&_hx_pos_94b10b66a3cf0a9a_27_reset)
HXLINE(  28)		this->super::reset();
HXLINE(  29)		this->position = (int)0;
HXLINE(  30)		this->shader = null();
            	}


void FlxDrawTilesItem_obj::dispose(){
            	HX_STACKFRAME(&_hx_pos_94b10b66a3cf0a9a_34_dispose)
HXLINE(  35)		this->super::dispose();
HXLINE(  36)		this->drawData = null();
HXLINE(  37)		this->shader = null();
            	}


void FlxDrawTilesItem_obj::addQuad( ::flixel::graphics::frames::FlxFrame frame, ::flixel::math::FlxMatrix matrix, ::openfl::_legacy::geom::ColorTransform transform){
            	HX_STACKFRAME(&_hx_pos_94b10b66a3cf0a9a_41_addQuad)
HXLINE(  42)		{
HXLINE(  42)			::Array< Float > _hx_tmp = this->drawData;
HXDLIN(  42)			_hx_tmp[this->position++] = matrix->tx;
            		}
HXLINE(  43)		{
HXLINE(  43)			::Array< Float > _hx_tmp1 = this->drawData;
HXDLIN(  43)			_hx_tmp1[this->position++] = matrix->ty;
            		}
HXLINE(  45)		 ::flixel::math::FlxRect rect = frame->frame;
HXLINE(  47)		{
HXLINE(  47)			::Array< Float > _hx_tmp2 = this->drawData;
HXDLIN(  47)			_hx_tmp2[this->position++] = rect->x;
            		}
HXLINE(  48)		{
HXLINE(  48)			::Array< Float > _hx_tmp3 = this->drawData;
HXDLIN(  48)			_hx_tmp3[this->position++] = rect->y;
            		}
HXLINE(  49)		{
HXLINE(  49)			::Array< Float > _hx_tmp4 = this->drawData;
HXDLIN(  49)			_hx_tmp4[this->position++] = rect->width;
            		}
HXLINE(  50)		{
HXLINE(  50)			::Array< Float > _hx_tmp5 = this->drawData;
HXDLIN(  50)			_hx_tmp5[this->position++] = rect->height;
            		}
HXLINE(  52)		{
HXLINE(  52)			::Array< Float > _hx_tmp6 = this->drawData;
HXDLIN(  52)			_hx_tmp6[this->position++] = matrix->a;
            		}
HXLINE(  53)		{
HXLINE(  53)			::Array< Float > _hx_tmp7 = this->drawData;
HXDLIN(  53)			_hx_tmp7[this->position++] = matrix->b;
            		}
HXLINE(  54)		{
HXLINE(  54)			::Array< Float > _hx_tmp8 = this->drawData;
HXDLIN(  54)			_hx_tmp8[this->position++] = matrix->c;
            		}
HXLINE(  55)		{
HXLINE(  55)			::Array< Float > _hx_tmp9 = this->drawData;
HXDLIN(  55)			_hx_tmp9[this->position++] = matrix->d;
            		}
HXLINE(  57)		bool _hx_tmp10;
HXDLIN(  57)		if (this->colored) {
HXLINE(  57)			_hx_tmp10 = hx::IsNotNull( transform );
            		}
            		else {
HXLINE(  57)			_hx_tmp10 = false;
            		}
HXDLIN(  57)		if (_hx_tmp10) {
HXLINE(  59)			{
HXLINE(  59)				::Array< Float > _hx_tmp11 = this->drawData;
HXDLIN(  59)				_hx_tmp11[this->position++] = transform->redMultiplier;
            			}
HXLINE(  60)			{
HXLINE(  60)				::Array< Float > _hx_tmp12 = this->drawData;
HXDLIN(  60)				_hx_tmp12[this->position++] = transform->greenMultiplier;
            			}
HXLINE(  61)			{
HXLINE(  61)				::Array< Float > _hx_tmp13 = this->drawData;
HXDLIN(  61)				_hx_tmp13[this->position++] = transform->blueMultiplier;
            			}
            		}
HXLINE(  64)		{
HXLINE(  64)			Float f;
HXDLIN(  64)			if (hx::IsNotNull( transform )) {
HXLINE(  64)				f = transform->alphaMultiplier;
            			}
            			else {
HXLINE(  64)				f = ((Float)1.0);
            			}
HXDLIN(  64)			::Array< Float > _hx_tmp14 = this->drawData;
HXDLIN(  64)			_hx_tmp14[this->position++] = f;
            		}
            	}


void FlxDrawTilesItem_obj::setNext(Float f){
            	HX_STACKFRAME(&_hx_pos_94b10b66a3cf0a9a_79_setNext)
HXDLIN(  79)		::Array< Float > _hx_tmp = this->drawData;
HXDLIN(  79)		_hx_tmp[this->position++] = f;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxDrawTilesItem_obj,setNext,(void))

void FlxDrawTilesItem_obj::render( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_94b10b66a3cf0a9a_83_render)
HXLINE(  84)		bool _hx_tmp;
HXDLIN(  84)		if (!(!(::flixel::FlxG_obj::renderTile))) {
HXLINE(  84)			_hx_tmp = (this->position <= (int)0);
            		}
            		else {
HXLINE(  84)			_hx_tmp = true;
            		}
HXDLIN(  84)		if (_hx_tmp) {
HXLINE(  85)			return;
            		}
HXLINE(  87)		int flags = (int)56;
HXLINE(  89)		if (this->colored) {
HXLINE(  90)			flags = ((int)flags | (int)(int)4);
            		}
HXLINE(  97)		flags = ((int)flags | (int)this->blending);
HXLINE( 100)		 ::openfl::_legacy::display::Graphics _hx_tmp1 = camera->canvas->get_graphics();
HXDLIN( 100)		 ::openfl::_legacy::display::Tilesheet _hx_tmp2 = this->graphics->get_tilesheet();
HXLINE( 101)		bool _hx_tmp3;
HXDLIN( 101)		if (!(camera->antialiasing)) {
HXLINE( 101)			_hx_tmp3 = this->antialiasing;
            		}
            		else {
HXLINE( 101)			_hx_tmp3 = true;
            		}
HXLINE( 100)		_hx_tmp1->drawTiles(_hx_tmp2,this->drawData,_hx_tmp3,flags,this->position);
HXLINE( 106)		this->super::render(camera);
            	}


int FlxDrawTilesItem_obj::get_numTiles(){
            	HX_STACKFRAME(&_hx_pos_94b10b66a3cf0a9a_110_get_numTiles)
HXLINE( 111)		int elementsPerTile = (int)8;
HXLINE( 112)		if (this->colored) {
HXLINE( 113)			elementsPerTile = (elementsPerTile + (int)3);
            		}
HXLINE( 119)		return ::Std_obj::_hx_int(((Float)this->position / (Float)elementsPerTile));
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxDrawTilesItem_obj,get_numTiles,return )

int FlxDrawTilesItem_obj::get_numVertices(){
            	HX_STACKFRAME(&_hx_pos_94b10b66a3cf0a9a_124_get_numVertices)
HXDLIN( 124)		return ((int)4 * this->get_numTiles());
            	}


int FlxDrawTilesItem_obj::get_numTriangles(){
            	HX_STACKFRAME(&_hx_pos_94b10b66a3cf0a9a_129_get_numTriangles)
HXDLIN( 129)		return ((int)2 * this->get_numTiles());
            	}



hx::ObjectPtr< FlxDrawTilesItem_obj > FlxDrawTilesItem_obj::__new() {
	hx::ObjectPtr< FlxDrawTilesItem_obj > __this = new FlxDrawTilesItem_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< FlxDrawTilesItem_obj > FlxDrawTilesItem_obj::__alloc(hx::Ctx *_hx_ctx) {
	FlxDrawTilesItem_obj *__this = (FlxDrawTilesItem_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(FlxDrawTilesItem_obj), true, "flixel.graphics.tile.FlxDrawTilesItem"));
	*(void **)__this = FlxDrawTilesItem_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

FlxDrawTilesItem_obj::FlxDrawTilesItem_obj()
{
}

void FlxDrawTilesItem_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxDrawTilesItem);
	HX_MARK_MEMBER_NAME(drawData,"drawData");
	HX_MARK_MEMBER_NAME(position,"position");
	HX_MARK_MEMBER_NAME(shader,"shader");
	 ::flixel::graphics::tile::FlxDrawBaseItem_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxDrawTilesItem_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(drawData,"drawData");
	HX_VISIT_MEMBER_NAME(position,"position");
	HX_VISIT_MEMBER_NAME(shader,"shader");
	 ::flixel::graphics::tile::FlxDrawBaseItem_obj::__Visit(HX_VISIT_ARG);
}

hx::Val FlxDrawTilesItem_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"reset") ) { return hx::Val( reset_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"shader") ) { return hx::Val( shader ); }
		if (HX_FIELD_EQ(inName,"render") ) { return hx::Val( render_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"dispose") ) { return hx::Val( dispose_dyn() ); }
		if (HX_FIELD_EQ(inName,"addQuad") ) { return hx::Val( addQuad_dyn() ); }
		if (HX_FIELD_EQ(inName,"setNext") ) { return hx::Val( setNext_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"drawData") ) { return hx::Val( drawData ); }
		if (HX_FIELD_EQ(inName,"position") ) { return hx::Val( position ); }
		if (HX_FIELD_EQ(inName,"numTiles") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_numTiles() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"get_numTiles") ) { return hx::Val( get_numTiles_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_numVertices") ) { return hx::Val( get_numVertices_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"get_numTriangles") ) { return hx::Val( get_numTriangles_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val FlxDrawTilesItem_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"shader") ) { shader=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"drawData") ) { drawData=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"position") ) { position=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FlxDrawTilesItem_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("drawData","\x4e","\x00","\xcd","\x56"));
	outFields->push(HX_HCSTRING("position","\xa9","\xa0","\xfa","\xca"));
	outFields->push(HX_HCSTRING("numTiles","\x5f","\x11","\x45","\xcd"));
	outFields->push(HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo FlxDrawTilesItem_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*Array< Float >*/ ,(int)offsetof(FlxDrawTilesItem_obj,drawData),HX_HCSTRING("drawData","\x4e","\x00","\xcd","\x56")},
	{hx::fsInt,(int)offsetof(FlxDrawTilesItem_obj,position),HX_HCSTRING("position","\xa9","\xa0","\xfa","\xca")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(FlxDrawTilesItem_obj,shader),HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *FlxDrawTilesItem_obj_sStaticStorageInfo = 0;
#endif

static ::String FlxDrawTilesItem_obj_sMemberFields[] = {
	HX_HCSTRING("drawData","\x4e","\x00","\xcd","\x56"),
	HX_HCSTRING("position","\xa9","\xa0","\xfa","\xca"),
	HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d"),
	HX_HCSTRING("reset","\xcf","\x49","\xc8","\xe6"),
	HX_HCSTRING("dispose","\x9f","\x80","\x4c","\xbb"),
	HX_HCSTRING("addQuad","\x88","\x7b","\x47","\x87"),
	HX_HCSTRING("setNext","\xb5","\xc5","\x86","\x0e"),
	HX_HCSTRING("render","\x56","\x6b","\x29","\x05"),
	HX_HCSTRING("get_numTiles","\x68","\xc5","\x5e","\x82"),
	HX_HCSTRING("get_numVertices","\xf6","\xc7","\x0d","\x17"),
	HX_HCSTRING("get_numTriangles","\x0e","\x26","\x50","\x2b"),
	::String(null()) };

static void FlxDrawTilesItem_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxDrawTilesItem_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxDrawTilesItem_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxDrawTilesItem_obj::__mClass,"__mClass");
};

#endif

hx::Class FlxDrawTilesItem_obj::__mClass;

void FlxDrawTilesItem_obj::__register()
{
	hx::Object *dummy = new FlxDrawTilesItem_obj;
	FlxDrawTilesItem_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.graphics.tile.FlxDrawTilesItem","\x11","\x72","\xa4","\xdb");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = FlxDrawTilesItem_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(FlxDrawTilesItem_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< FlxDrawTilesItem_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxDrawTilesItem_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxDrawTilesItem_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxDrawTilesItem_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace graphics
} // end namespace tile
